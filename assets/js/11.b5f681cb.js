(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{339:function(a,t,s){"use strict";s.r(t);var _=s(4),e=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"一、语言特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、语言特性"}},[a._v("#")]),a._v(" 一、语言特性")]),a._v(" "),t("h3",{attrs:{id:"_1-简洁易读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-简洁易读"}},[a._v("#")]),a._v(" 1，简洁易读")]),a._v(" "),t("ul",[t("li",[a._v("go语言通过设计简洁、清晰的语法和标准库，使得代码更加易读易写；")]),a._v(" "),t("li",[a._v("同时，还避免了一些语言中常见的复杂特性和概念，如继承和多态等，采用接口实现多态性，减少了冗余代码，提高了代码的可读性；")])]),a._v(" "),t("h3",{attrs:{id:"_2-并发支持"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-并发支持"}},[a._v("#")]),a._v(" 2，并发支持")]),a._v(" "),t("ul",[t("li",[a._v("go语言内置了原生的并发支持，主要是通过 goroutine 和 channel 实现的；")]),a._v(" "),t("li",[a._v("goroutine 是一种轻量级的线程，与传统的线程相比，goroutine 的创建和销毁开销更小，因此可以高效地运行成千上万个并发任务，并且可以非常简单的创建一个 goroutine；")]),a._v(" "),t("li",[t("strong",[a._v("通过 GMP 调度模型，让用户态的 N 个 goroutine 运行在内核态的 M 个线程上，使得并发任务 goroutine 的切换发生在用户态")]),a._v("；")]),a._v(" "),t("li",[t("strong",[a._v("channel 则提供了在多个 goroutine 之间进行通信和数据交换的机制，避免了共享内存带来的竞争和同步问题")]),a._v("；")])]),a._v(" "),t("h3",{attrs:{id:"_3-内存管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-内存管理"}},[a._v("#")]),a._v(" 3，内存管理")]),a._v(" "),t("ul",[t("li",[a._v("go 语言具有自动垃圾回收（Garbage Collection）机制，"),t("strong",[a._v("它基于引用计数和标记-清除算法，定期对无用的对象进行回收，释放内存空间")]),a._v("；")]),a._v(" "),t("li",[a._v("开发者无需手动管理内存分配与释放，这减轻了开发负担，同时也降低了内存泄漏和指针错位等问题的风险；")])]),a._v(" "),t("h3",{attrs:{id:"_4-高效编译"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-高效编译"}},[a._v("#")]),a._v(" 4，高效编译")]),a._v(" "),t("ul",[t("li",[a._v("go 语言拥有快速的编译速度，主要是因为它采用了"),t("strong",[a._v("基于单一静态链接库")]),a._v("的模块化设计，这种设计方式可以减少编译和链接时的依赖关系，提高编译速度；")]),a._v(" "),t("li",[a._v("go 语言还采用了"),t("strong",[a._v("增量式编译和缓存技术")]),a._v("，可以减少重复编译和提高构建速度。")])]),a._v(" "),t("h3",{attrs:{id:"_5-跨平台支持"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-跨平台支持"}},[a._v("#")]),a._v(" 5，跨平台支持")]),a._v(" "),t("ul",[t("li",[a._v("go 语言提供了丰富的标准库和操作系统接口，可以直接调用操作系统功能，从而实现跨平台支持；")]),a._v(" "),t("li",[a._v("go 语言提供了对多种操作系统的支持，包括Linux、Windows、macOS等，还提供了对不同 CPU 架构的支持，如x86、ARM等；")])]),a._v(" "),t("h3",{attrs:{id:"_6-静态类型和类型推断"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-静态类型和类型推断"}},[a._v("#")]),a._v(" 6，静态类型和类型推断")]),a._v(" "),t("ul",[t("li",[a._v("go 语言是一种静态类型语言，可以在编译阶段发现一些类型错误，避免了一些运行期错误；")]),a._v(" "),t("li",[a._v("go 语言还支持类型推断，可以根据上下文自动推导变量的类型，大大简化了代码书写，同时也保留了静态类型语言的安全性；")])]),a._v(" "),t("h3",{attrs:{id:"_7-强大的工具链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-强大的工具链"}},[a._v("#")]),a._v(" 7，强大的工具链")]),a._v(" "),t("ul",[t("li",[a._v("go 语言提供了丰富的工具链，包括"),t("strong",[a._v("格式化工具、测试工具、性能分析工具")]),a._v("等，这些工具能够帮助开发者编写、测试和优化代码，使得开发过程更加高效和可控；")])]),a._v(" "),t("h2",{attrs:{id:"二、数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、数据类型"}},[a._v("#")]),a._v(" 二、数据类型")]),a._v(" "),t("ul",[t("li",[a._v("go 是一种强类型语言，数据类型之间有着严格的区分；")]),a._v(" "),t("li",[a._v("常见的数据类型有："),t("div",{staticClass:"language-go line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-go"}},[t("code",[t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("bool")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 布尔类型，值为 true or false")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("uint8")]),a._v("   "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 无符号 8 位整形，范围 0 ~ 255")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("uint16")]),a._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 无符号 16 位整形，范围 0 ~ 65535")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("uint32")]),a._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 无符号 32 位整形，范围 0 ~ 4294967295")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("uint64")]),a._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 无符号 64 位整形，范围 0 ~ 18446744073709551615")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("uint")]),a._v("    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 64 位机器上等于 uint64，32 位机器上等于 uint32")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("int8")]),a._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 有符号 8 位整形，范围 -128 ~ 127   ")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("int16")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 有符号 16 位整形，范围 -32768 ~ 32767")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("int32")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 有符号 32 位整形，范围 -2147483648 - 2147483647")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("int64")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 有符号 64 位整形，范围 -9223372036854775808 ~ 9223372036854775807")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("int")]),a._v("   "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 64 位机器上等于 int64，32 位机器上等于 int32")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("float32")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 32 位浮点数，符合 IEEE-754 标准")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("float64")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 64 位浮点数，符合 IEEE-754 标准")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("string")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 字符串类型，可以为空，字符不可改变")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("complex64")]),a._v("   "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 64 位复数，实部和虚部都是 float32")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("complex128")]),a._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 128 位复数，实部和虚部都是 float64")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("uintptr")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 整数类型，足够大，可以容纳任何指针的位模式")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("byte")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// uint8 的别名，在所有方面都等同于 uint8，用于区分字节值和 8 位无符号整数值")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("rune")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// int32 的别名，在所有方面都等同于 int32，用于区分字符值和整数值")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("nil")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 一个预先声明的标识符，表示指针、通道、func、接口、映射或切片类型的零值")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br"),t("span",{staticClass:"line-number"},[a._v("14")]),t("br"),t("span",{staticClass:"line-number"},[a._v("15")]),t("br"),t("span",{staticClass:"line-number"},[a._v("16")]),t("br"),t("span",{staticClass:"line-number"},[a._v("17")]),t("br"),t("span",{staticClass:"line-number"},[a._v("18")]),t("br"),t("span",{staticClass:"line-number"},[a._v("19")]),t("br"),t("span",{staticClass:"line-number"},[a._v("20")]),t("br"),t("span",{staticClass:"line-number"},[a._v("21")]),t("br"),t("span",{staticClass:"line-number"},[a._v("22")]),t("br"),t("span",{staticClass:"line-number"},[a._v("23")]),t("br"),t("span",{staticClass:"line-number"},[a._v("24")]),t("br"),t("span",{staticClass:"line-number"},[a._v("25")]),t("br"),t("span",{staticClass:"line-number"},[a._v("26")]),t("br"),t("span",{staticClass:"line-number"},[a._v("27")]),t("br"),t("span",{staticClass:"line-number"},[a._v("28")]),t("br"),t("span",{staticClass:"line-number"},[a._v("29")]),t("br")])])])]),a._v(" "),t("h2",{attrs:{id:"三、数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、数据结构"}},[a._v("#")]),a._v(" 三、数据结构")]),a._v(" "),t("h3",{attrs:{id:"_1-slice"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-slice"}},[a._v("#")]),a._v(" 1，slice")]),a._v(" "),t("ul",[t("li",[a._v("切片，用于存储一组同类型数据；")]),a._v(" "),t("li",[a._v("底层主要是长度、容量、指向数组的指针组成，当触发扩容时，该指针的值会发生变化；")])]),a._v(" "),t("h3",{attrs:{id:"_2-数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-数组"}},[a._v("#")]),a._v(" 2，数组")]),a._v(" "),t("ul",[t("li",[a._v("固定容量的切片，或是根据存储的数据长度自动推导容量大小；")]),a._v(" "),t("li",[a._v("没有 append 函数，不会触发扩容；")]),a._v(" "),t("li",[a._v("只能通过索引访问、修改、添加元素；")])]),a._v(" "),t("h3",{attrs:{id:"_3-map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-map"}},[a._v("#")]),a._v(" 3，map")]),a._v(" "),t("ul",[t("li",[a._v("映射结构，用于存储 key、value 的键值对，key 的类型相同，value 的类型也要相同，key 和 value 类型可以不同；")]),a._v(" "),t("li",[a._v("底层主要是通过数组和哈希的方式实现，并通过链接地址法处理哈希冲突，同时 key 和 value 是分开存储的，以方便内存对齐和内存回收；")]),a._v(" "),t("li",[a._v("当 map 的负载因子达到一定值时会触发扩容；")])]),a._v(" "),t("h3",{attrs:{id:"_4-struct"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-struct"}},[a._v("#")]),a._v(" 4，struct")]),a._v(" "),t("ul",[t("li",[a._v("结构体类型，用于存储不同类型的数据；")]),a._v(" "),t("li",[a._v("空结构体的大小为 0；")])]),a._v(" "),t("h3",{attrs:{id:"_5-interface"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-interface"}},[a._v("#")]),a._v(" 5，interface")]),a._v(" "),t("ul",[t("li",[a._v("接口类型，用于定义对象的行为和方法集合；")]),a._v(" "),t("li",[a._v("接口提供了一种方式来实现多态性，允许不同的类型以不同的方式进行交互；")]),a._v(" "),t("li",[a._v("接口定义了一个或多个方法的签名，但没有具体的实现，任何类型只要实现了接口中定义的所有方法，就被认为是该接口类型的实现；")]),a._v(" "),t("li",[a._v("所有类型均是空接口的实现；")])]),a._v(" "),t("h2",{attrs:{id:"四、内置函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、内置函数"}},[a._v("#")]),a._v(" 四、内置函数")]),a._v(" "),t("h3",{attrs:{id:"_1-append"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-append"}},[a._v("#")]),a._v(" 1，append")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("func append(slice []Type, elems ...Type) []Type")]),a._v("；")]),a._v(" "),t("li",[a._v("append 内置函数将元素追加到切片的末尾；")]),a._v(" "),t("li",[a._v("如果切片有足够的容量，则直接将新元素添加到底层数组；")]),a._v(" "),t("li",[a._v("如果没有，将触发扩容分配一个新的底层数组，此时指向数组的指针指会发生改变，append 返回更新后的切片；")])]),a._v(" "),t("h3",{attrs:{id:"_2-copy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-copy"}},[a._v("#")]),a._v(" 2，copy")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("func copy(dst, src []Type) int")]),a._v("；")]),a._v(" "),t("li",[a._v("copy 内置函数将元素从源切片复制到目标切片中；")]),a._v(" "),t("li",[a._v("作为特殊情况，它还会将字节从字符串复制到字节切片；")]),a._v(" "),t("li",[a._v("源和目标可能重叠，可能会出现意想不到的情况；")]),a._v(" "),t("li",[a._v("copy 返回复制的元素数，即 len（src） 和 len（dst） 的最小值；")])]),a._v(" "),t("h3",{attrs:{id:"_3-delete"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-delete"}},[a._v("#")]),a._v(" 3，delete")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("delete(m map[Type]Type1, key Type)")]),a._v("；")]),a._v(" "),t("li",[a._v("delete 内置函数从映射中删除具有指定键 "),t("code",[a._v("m[key]")]),a._v(" 的元素。如果 "),t("code",[a._v("m")]),a._v(" 为 "),t("code",[a._v("nil")]),a._v(" 或没有此类元素，则 delete 为空操作。")])]),a._v(" "),t("h3",{attrs:{id:"_4-len"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-len"}},[a._v("#")]),a._v(" 4，len")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("func len(v Type) int")]),a._v("；")]),a._v(" "),t("li",[a._v("len 内置函数根据其类型返回 v 的长度：\n"),t("ul",[t("li",[a._v("数组或数组指针：v 中的元素数量；")]),a._v(" "),t("li",[a._v("slice 或 map：返回 v 中元素数量，如果 v 为 nil，则 len（v） 为零；")]),a._v(" "),t("li",[a._v("string：v 中的字节数；")]),a._v(" "),t("li",[a._v("channel：通道缓冲区中排队（未读）的元素数，如果 v 为 nil，则 len（v） 为零。")])])])]),a._v(" "),t("h3",{attrs:{id:"_5-cap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-cap"}},[a._v("#")]),a._v(" 5，cap")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("func cap(v Type) int")]),a._v("；")]),a._v(" "),t("li",[a._v("cap 内置函数根据其类型返回 v 的容量：\n"),t("ul",[t("li",[a._v("数组或数组指针：v 中的元素数量；（与 len（v） 相同）；")]),a._v(" "),t("li",[a._v("slice：可以达到的最大长度，如果 v 为 nil，则 cap（v） 为零；")]),a._v(" "),t("li",[a._v("channel：通道缓冲区容量，如果 v 为 nil，则 cap（v） 为零；")])])])]),a._v(" "),t("h3",{attrs:{id:"_6-new"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-new"}},[a._v("#")]),a._v(" 6，new")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("func new(Type) *Type")]),a._v("；")]),a._v(" "),t("li",[a._v("用来分配内存，第一个参数是类型，而不是值，返回的值是指向该类型新分配的零值的指针；")])]),a._v(" "),t("h3",{attrs:{id:"_7-make"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-make"}},[a._v("#")]),a._v(" 7，make")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("func make(t Type, size ...IntegerType) Type")]),a._v("；")]),a._v(" "),t("li",[a._v("用来分配并初始化"),t("code",[a._v("slice、map、chan")]),a._v("类型的对象；")]),a._v(" "),t("li",[a._v("与 new 一样，第一个参数是类型，而不是值；与 new 不同的是，make 的返回类型与其参数的类型相同，而不是指向它的指针；")]),a._v(" "),t("li",[a._v("参数和结果的规范取决于创建的类型：\n"),t("ul",[t("li",[t("code",[a._v("slice")]),a._v("：size 指定长度，切片的容量等于其长度。可以提供第二个整数参数来指定不同的容量，必须不小于长度；")]),a._v(" "),t("li",[t("code",[a._v("map")]),a._v("：为空 map 分配足够的空间来容纳指定数量的元素，可以省略 size，在这种情况下，将分配较小的起始大小；")]),a._v(" "),t("li",[t("code",[a._v("chan")]),a._v("：通道的缓冲区使用指定的缓冲区容量进行初始化，如果为零或省略大小，则通道无缓冲；")])])])]),a._v(" "),t("h3",{attrs:{id:"_8-close"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-close"}},[a._v("#")]),a._v(" 8，close")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("func close(c chan<- Type)")]),a._v("；")]),a._v(" "),t("li",[a._v("close 内置函数关闭通道，该通道必须是双向的或仅发送的；")]),a._v(" "),t("li",[a._v("通道应该只由发送方执行，而不是由接收方执行，并且具有在接收到最后一个发送的值后关闭通道的效果；")]),a._v(" "),t("li",[a._v("从关闭后的通道 c 接收到最后一个值后，c 的任何接收 goroutine 都将成功接收到通道元素的零值，而不会被阻塞；")]),a._v(" "),t("li",[a._v("对于关闭后的通道，x, ok := <-c 会将 ok 设置为 false；")])]),a._v(" "),t("h3",{attrs:{id:"_9-panic"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-panic"}},[a._v("#")]),a._v(" 9，panic")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("func panic(v interface{})")]),a._v("；")]),a._v(" "),t("li",[a._v("panic 内置函数停止当前 goroutine 的正常执行；")]),a._v(" "),t("li",[a._v("当函数 F 调用 panic 时，F 的正常执行会立即停止，任何被 F 延迟执行的函数都以平常的方式运行，然后 F 返回给其调用方；")]),a._v(" "),t("li",[a._v("对于调用方 G，对 F 的调用就像对 panic 的调用一样，终止 G 的执行并运行任何延迟的函数；")]),a._v(" "),t("li",[a._v("这种情况一直持续到执行 goroutine 中的所有函数以相反的顺序停止为止，此时，程序将终止，并带有非零退出代码；")]),a._v(" "),t("li",[a._v("此终止序列称为 panicking，可通过内置函数 recover 进行捕获；")])]),a._v(" "),t("h3",{attrs:{id:"_10-recover"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-recover"}},[a._v("#")]),a._v(" 10，recover")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("func recover() interface{}")]),a._v("；")]),a._v(" "),t("li",[a._v("recover 内置函数允许程序管理 goroutine 的 panic 行为，且只能捕获当前 goroutine，无法夸 goroutine；")]),a._v(" "),t("li",[a._v("在延迟函数（但不是它调用的任何函数）中执行恢复调用会通过恢复正常执行来停止 panic 序列，并检索传递给 panic 调用的错误值；")]),a._v(" "),t("li",[a._v("如果在延迟函数之外调用 recover，则不会停止 panic 序列，即 recover 只能在 defer 中执行，在其他作用域无效，且只能在与 panic 同级的 defer 函数中才有效，多级嵌套 defer 后，最里层的 recover 无法捕获外层的 panic；")]),a._v(" "),t("li",[a._v("当 goroutine 没有 panic ，或者 panic 的参数为 nil，则 recover 返回 nil；")]),a._v(" "),t("li",[a._v("recover 的返回值能够说明 goroutine 是否处于 panic 状态；")])]),a._v(" "),t("h3",{attrs:{id:"_11-print"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-print"}},[a._v("#")]),a._v(" 11，print")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("func print(args ...Type)")]),a._v("；")]),a._v(" "),t("li",[a._v("print 内置函数以特定地实现方式格式化其参数，并将结果写入标准错误；")])]),a._v(" "),t("h3",{attrs:{id:"_12-println"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-println"}},[a._v("#")]),a._v(" 12，println")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("func println(args ...Type)")]),a._v("；")]),a._v(" "),t("li",[a._v("println 内置函数以特定地实现方式格式化其参数，并将结果写入标准错误；")]),a._v(" "),t("li",[a._v("始终在参数之间添加空格，并附加换行符；")])]),a._v(" "),t("h3",{attrs:{id:"_13-complex"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-complex"}},[a._v("#")]),a._v(" 13，complex")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("func complex(r, i FloatType) ComplexType")]),a._v("；")]),a._v(" "),t("li",[a._v("complex 内置函数从两个浮点值构造一个复数值；")]),a._v(" "),t("li",[a._v("实部和虚部必须具有相同的大小，即 float32 或 float64；")]),a._v(" "),t("li",[a._v("并且返回值将是相应的复数类型（float32 为 complex64，float64 为 complex128）；")])]),a._v(" "),t("h3",{attrs:{id:"_14-real"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-real"}},[a._v("#")]),a._v(" 14，real")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("func real(c ComplexType) FloatType")]),a._v("；")]),a._v(" "),t("li",[a._v("real 内置函数返回复数 c 的实数部分，返回值将是与 c 类型对应的浮点类型；")])]),a._v(" "),t("h3",{attrs:{id:"_15-imag"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_15-imag"}},[a._v("#")]),a._v(" 15，imag")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("func imag(c ComplexType) FloatType")]),a._v("；")]),a._v(" "),t("li",[a._v("imag 内置函数返回复数 c 的虚部，返回值将是与 c 类型对应的浮点类型；")])]),a._v(" "),t("h2",{attrs:{id:"五、同步原语"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、同步原语"}},[a._v("#")]),a._v(" 五、同步原语")]),a._v(" "),t("h3",{attrs:{id:"_1-mutex"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-mutex"}},[a._v("#")]),a._v(" 1，Mutex")]),a._v(" "),t("ul",[t("li",[a._v("互斥锁，同一时刻只能被一个 goroutine 拥有；")]),a._v(" "),t("li",[a._v("写写、写读、读读均互斥；")])]),a._v(" "),t("h3",{attrs:{id:"_2-rwmutex"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-rwmutex"}},[a._v("#")]),a._v(" 2，RWMutex")]),a._v(" "),t("ul",[t("li",[a._v("读写锁，同一时刻只能被一个写 goroutine 拥有，或同时被多个读 goroutine 拥有；")]),a._v(" "),t("li",[a._v("写写、写读互斥，读读不互斥；")])]),a._v(" "),t("h3",{attrs:{id:"_3-waitgroup"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-waitgroup"}},[a._v("#")]),a._v(" 3，WaitGroup")]),a._v(" "),t("ul",[t("li",[a._v("用于等待一组 goroutine 的返回，例如并发请求后等待结果返回再统一处理；")])]),a._v(" "),t("h3",{attrs:{id:"_4-once"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-once"}},[a._v("#")]),a._v(" 4，Once")]),a._v(" "),t("ul",[t("li",[a._v("用于保证运行期间，某段代码只执行一次，例如初始化某个配置；")])]),a._v(" "),t("h3",{attrs:{id:"_5-cond"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-cond"}},[a._v("#")]),a._v(" 5，Cond")]),a._v(" "),t("h3",{attrs:{id:"_6-pool"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-pool"}},[a._v("#")]),a._v(" 6，Pool")]),a._v(" "),t("h3",{attrs:{id:"_7-atomic"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-atomic"}},[a._v("#")]),a._v(" 7，atomic")]),a._v(" "),t("h2",{attrs:{id:"六、关键字"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、关键字"}},[a._v("#")]),a._v(" 六、关键字")]),a._v(" "),t("h3",{attrs:{id:"_1-for"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-for"}},[a._v("#")]),a._v(" 1，for")]),a._v(" "),t("h3",{attrs:{id:"_2-range"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-range"}},[a._v("#")]),a._v(" 2，range")]),a._v(" "),t("h3",{attrs:{id:"_3-defer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-defer"}},[a._v("#")]),a._v(" 3，defer")]),a._v(" "),t("h3",{attrs:{id:"_4-select"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-select"}},[a._v("#")]),a._v(" 4，select")]),a._v(" "),t("h3",{attrs:{id:"_5-channel"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-channel"}},[a._v("#")]),a._v(" 5，channel")]),a._v(" "),t("h3",{attrs:{id:"_6-reflect"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-reflect"}},[a._v("#")]),a._v(" 6，reflect")]),a._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[a._v("提示")]),a._v(" "),t("p",[a._v("持续更新中……")])])])}),[],!1,null,null,null);t.default=e.exports}}]);